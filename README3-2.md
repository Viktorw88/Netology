Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
```
Ответ:
cd - встроенная команда.
Встроенная, потому что, при работе внутри сессии терминала логичнее менять указатель на текущую директорию внутренней функцией

Если использовать внешний вызов, то он будет работать со своим окружением, и менять текущий каталог внутри своего окружения, 
на вызвавший shell влиять не будет  

Теоретически можно сделать cd внешней программой, но после смены директории потребуется вызвать bash из нового каталога, но тогда 
мы получим новый shell.
И выходя из сессии придется выходить из всех сессий, которые создали при каждом вызове внешней cd.
```

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. 
Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
```
Ответ:
grep <some_string> <some_file> -c

Пример:
vagrant@vagrant:~$ cat textfile.txt
sometext
lorem ipsum
123
1234
vagrant@vagrant:~$ grep 123 textfile.txt -c
2
vagrant@vagrant:~$ grep 123 textfile.txt |wc -l
2
```

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
Ответ: ![img](https://user-images.githubusercontent.com/94568542/148688518-0a20965a-c444-4240-9ae9-4a450603fb17.jpg) systemd(1)-VBoxService(863)

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

```
Ответ:

Вызов из dev/tty1:
vagrant@vagrant:~$ ls -l \root 2>/dev/tty4
vagrant@vagrant:~$ sudo chvt 4

Вывод в другой сессии dev/tty4:    

vagrant@vagrant:~$ who
vagrant  tty1        2022-01-10 15:38 
vagrant  tty4        2022-01-10 16:11 
vagrant@vagrant:~$ ls: cannot access 'root': No such file or directory
```
![4](https://user-images.githubusercontent.com/94568542/148800260-bacc183d-bd79-4d64-99e3-843f2b65de28.jpg)


5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

Ответ: Да. пример:

![5](https://user-images.githubusercontent.com/94568542/148794000-b6a7aba8-2eca-4dea-9862-4afcc7f0a437.jpg)

6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

```
Ответ
Вывести получится при использовании перенаправлении вывода:
echo Hello from pts0 to tty1 >/dev/tty1
Скриншот: 
```
![6](https://user-images.githubusercontent.com/94568542/148832025-f7de7511-12b4-411f-a1f5-95e3c7171d1d.jpg)


7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ:
```
bash 5>&1 - Создаст дескриптор с 5 и перенаправит его в stdout
echo netology > /proc/$$/fd/5 - выведет в дескриптор "5", который был перенаправлен в stdout

если запустить echo netology > /proc/$$/fd/5 в новой сессии, получим ошибку, так как такого дескриптора нет на данный момент 
в текущей(новой) сессии
    
vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
-bash: /proc/1507/fd/5: No such file or directory
vagrant@vagrant:~$ bash 5>&1
vagrant@vagrant:~$ echo netology > /proc.$$/fd/5
bash: /proc.1579/fd/5: No such file or directory
vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
netology
vagrant@vagrant:~$ 
```
![7](https://user-images.githubusercontent.com/94568542/148802429-087023b3-7d5a-444f-87aa-777211470fcb.jpg)

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Ответ:
```
vagrant@vagrant:~$ ls -l /root 9>&2 2>&1 1>&9 | grep denied -c 
1

9>&2 - новый дескриптор перенаправили в stderr
2>&1 - stderr перенаправили в stdout 
1>&9 - stdout - перенаправили в новый дескриптор
```
![8](https://user-images.githubusercontent.com/94568542/148804185-7bbb6aa5-8642-4920-96aa-5ba230ec696d.jpg)

9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

```
Ответ:
Будут выведены переменные окружения:
можно получить тоже самое (только с разделением переменных по строкам):
printenv или env
```
10. Используя man, опишите что доступно по адресам /proc/[pid]/cmdline, /proc/[pid]/exe.

Ответ:
/proc/[pid]/cmdline - полный путь до исполняемого файла процесса [PID]  (строка 215)
![10-1](https://user-images.githubusercontent.com/94568542/148805807-5cd41be9-9dba-4a43-a222-56bbf4d740e3.jpg)

/proc/[pid]/exe - содержит ссылку до файла запущенного для процесса [PID],  (строка 273)
                        cat выведет содержимое запущенного файла, 
                        запуск этого файла,  запустит еще одну копию самого файла 
![10-2](https://user-images.githubusercontent.com/94568542/148806298-042db931-a54f-4da1-bd42-1998da28bafb.jpg)

    
11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
```
Ответ:
vagrant@vagrant:~$ grep sse /proc/cpuinfo
SSE 4.2
```
![11](https://user-images.githubusercontent.com/94568542/148806023-e3282261-02e1-4d7c-bf6d-21adcf7f7a49.jpg)
    
12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```

Почитайте, почему так происходит, и как изменить поведение.
```
Ответ:
Как я понимаю при подключении ожидается пользователь, а не другой процесс, и нет локального tty в данный момент. 
Для запуска можно добавить -t  и команда исполняется c принудительным созданием псевдотерминала. 
```
![12](https://user-images.githubusercontent.com/94568542/148826879-e64ea24b-f0fb-4b65-8a0c-a4a3baf75139.jpg)

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

```
Ответ:
При первых запусках ругался на права, 10-patrace.conf
нашел что нужно установить значение  kernel.yama.ptrace_scope = 0 
использовал команду echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope
после чего процесс был перехвачен в screen, и продолжил работу после закрытия терминала. 
В pstree процесс не отображался, точнее отображался в виде процесса reptyr. не сразу сообразил что это то, что нужно 
```
14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

```
Ответ:
команда tee делает вывод одновременно и в файл, указанный в качестве параметра, и в stdout, 
в данном примере команда получает вывод из stdin, перенаправленный через pipe от stdout команды echo
и так как команда запущена от sudo , соответственно имеет права на запись в файл
```
