# Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"


## Задача 1

Сценарий выполения задачи:

- создайте свой репозиторий на https://hub.docker.com;
- выберете любой образ, который содержит веб-сервер Nginx;
- создайте свой fork образа;
- реализуйте функциональность:
запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
```
Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

Ответ:
```
https://hub.docker.com/r/victorw88/html/tags
```
![1](https://user-images.githubusercontent.com/94568542/165861520-0575ffe9-9913-4eb4-9f42-2193fc5c2611.jpg)



## Задача 2

Посмотрите на сценарий ниже и ответьте на вопрос:
"Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"

Детально опишите и обоснуйте свой выбор.

--

Сценарий:
- Высоконагруженное монолитное java веб-приложение;
- Nodejs веб-приложение;
- Мобильное приложение c версиями для Android и iOS;
- Шина данных на базе Apache Kafka;
- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
- Мониторинг-стек на базе Prometheus и Grafana;
- MongoDB, как основное хранилище данных для java-приложения;
- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

Ответ:
```
- Высоконагруженное монолитное java веб-приложение;
Так как в описании есть слово "высоконагруженное" - значит необходим физический доступ к ресурсам, без использования 
гипервизора виртуальной машины.
"Монолитное" - следует выбрать физический сервер. 

- Nodejs веб-приложение;
Так как это веб приложение, то для таких приложений достаточно контейнерной реализации Docker

- Мобильное приложение c версиями для Android и iOS;
Здесь следует использовать Виртуальную машину так как приложение в Docker не имеет GUI.

- Шина данных на базе Apache Kafka;
Здесь решение зависит от передаваемых данных или окружения (прод или тест), для прода и при важных/критичных данных лучше виртуальная машина,
для теста достаточно контейнерной реализации через Docker,  при условии что потеря данных при потере контейнера не является критичной,
то можно в контейнере.


- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash
  и две ноды kibana;
  Elasticsearсh лучше вынести на виртуальную машину, отказоустойчивость решается на уровне кластера, 
   logstash и kibana можно вынести в Docker контейнер, или тоже на виртуальные машины.
  
- Мониторинг-стек на базе Prometheus и Grafana;
 Здесь можно использовать Docker контейнеры - сами системы не хранят как таковых данных, плюсом будет в скорости развертывания


- MongoDB, как основное хранилище данных для java-приложения;
- Так как указано "хранилище" и не указано что "высоконагруженное" - использовать виртуальную машину, 
  хранить БД с данными в Docker контейнере не подходит

- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.
 Вероятно следует использовать отдельный физический сервер или виртуализацию, если есть сервер в наличии - тогда использовать сервер, 
 также необходима оценка доступных объемов хранения данных, плюс посчитать затраты на поддержку железа и другие затраты.
 Если исходя из задач будет понятно, что спустя недолгое время ожидается выход за пределы мощностей физического сервера, то 
 в перспективе можно выбрать виртуализацию.
```

## Задача 3

- Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
- Добавьте еще один файл в папку ```/data``` на хостовой машине;
- Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

Ответ:
```
- Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
```
![31](https://user-images.githubusercontent.com/94568542/165861046-93d8417f-da4b-476f-85db-684ad74680b1.jpg)


```
- Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
```
![32](https://user-images.githubusercontent.com/94568542/165861141-7f7b2b56-2347-42a6-a810-5bf3ad7877eb.jpg)


```
- Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
```
![33](https://user-images.githubusercontent.com/94568542/165861173-fd8a055f-5034-4aca-95d9-1e5fd22e2180.jpg)

```
- Добавьте еще один файл в папку ```/data``` на хостовой машине;
```
![34](https://user-images.githubusercontent.com/94568542/165861203-14b4c67b-8354-40a4-8124-3d8dde6a632b.jpg)

```
- Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.
```
![35](https://user-images.githubusercontent.com/94568542/165861264-d90dca0e-37aa-44fb-abe3-bffd81bad605.jpg)
